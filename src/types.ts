import UrbitMock from './Urbit';

/**
 * An urbit style path, rendered as a Javascript string,
 * supports dynamic parameters like `/:id/some/data`
 * @example
 * `"/updates"`
 */
export type Path = string;

/**
 * @p including leading sig, rendered as a string
 *
 * @example
 * ```typescript
 * "~sampel-palnet"
 * ```
 *
 */
export type Patp = string;

/**
 * @p not including leading sig, rendered as a string
 *
 * @example
 * ```typescript
 * "sampel-palnet"
 * ```
 *
 */
export type PatpNoSig = string;

/**
 * The name of a clay mark, as a string
 *
 * @example
 * ```typescript
 * "graph-update"
 * ```
 */
export type Mark = string;

/**
 * The name of a gall agent, as a string
 *
 * @example
 *
 * ```typescript
 * "graph-store"
 * ```
 */
export type GallAgent = string;

/**
 * A function which determines a path match
 */
export type PathMatcher = (path: Path) => boolean;

/**
 * Description of an outgoing poke
 *
 * @typeParam Action - Typescript type of the data being poked
 */
export interface Poke<Action> {
  /**
   * Ship to poke. If left empty, the api lib will populate it with the ship that it is connected to.
   *
   * @remarks
   *
   * This should always be the ship that you are connected to
   *
   */
  ship?: PatpNoSig;
  /**
   */
  app: GallAgent;
  /**
   * Mark of the cage to be poked
   *
   */
  mark: Mark;
  /**
   * Vase of the cage of to be poked, as JSON
   */
  json: Action;
}

/**
 * Description of a scry request
 */
export interface Scry {
  /** {@inheritDoc GallAgent} */
  app: GallAgent;
  /** {@inheritDoc Path} */
  path: Path;
}

/**
 * Description of a thread request
 *
 * @typeParam Action - Typescript type of the data being poked
 */
export interface Thread<Action> {
  /**
   * The mark of the input vase
   */
  inputMark: Mark;
  /**
   * The mark of the output vase
   */
  outputMark: Mark;
  /**
   * Name of the thread
   *
   * @example
   * ```typescript
   * "graph-add-nodes"
   * ```
   */
  threadName: string;
  /**
   * Desk of thread
   */
  desk?: string;
  /**
   * Data of the input vase
   */
  body: Action;
}

export type Action = 'poke' | 'subscribe' | 'ack' | 'unsubscribe' | 'delete';

export interface PokeHandlers {
  onSuccess?: () => void;
  onError?: (e: any) => void;
}

export type PokeInterface<T> = PokeHandlers & Poke<T>;

export interface AuthenticationInterface {
  ship: string;
  url: string;
  code: string;
  handlers: Handler[];
  verbose?: boolean;
}

/**
 * Subscription event handlers
 *
 */
export interface SubscriptionInterface {
  /**
   * Handle negative %watch-ack
   */
  err?(error: any, id: string): void;
  /**
   * Handle %fact
   */
  event?(data: any): void;
  /**
   * Handle %kick
   */
  quit?(data: any): void;
}

export type OnceSubscriptionErr = 'quit' | 'nack' | 'timeout';

export interface SubscriptionRequestInterface extends SubscriptionInterface {
  /**
   * The app to subscribe to
   * @example
   * `"graph-store"`
   */
  app: GallAgent;
  /**
   * The path to which to subscribe
   * @example
   * `"/keys"`
   */
  path: Path;
}

export interface headers {
  'Content-Type': string;
  Cookie?: string;
}

export interface CustomEventHandler {
  (data: any, response: string): void;
}

export interface SSEOptions {
  headers?: {
    Cookie?: string;
  };
  withCredentials?: boolean;
}

export interface Message extends Record<string, any> {
  action: Action;
  id?: number;
}

/**
 * A function that returns a predefined response for a predefined action.
 *
 */

export interface UrbitResponse<DataType> {
  id: number;
  response: 'poke' | 'subscribe' | 'diff' | 'quit';
  json: DataType;
  ok?: boolean;
  err?: any;
}

export type WithMatcher<T> = T & {
  path: Path | PathMatcher;
};

export interface ScryHandler extends WithMatcher<Scry> {
  action: 'scry';
  /**
   * A function which generates the scry data
   */
  func: (req: Scry, api: UrbitMock, pathParams?: Record<string, string>) => any;
}

export function isScryHandler(handler: Handler): handler is ScryHandler {
  return handler.action === 'scry';
}

type Responder<Request> = (
  req: Message & Request,
  api: UrbitMock,
  pathParams?: Record<string, string>
) => UrbitResponse<any>;

export interface PokeHandler extends Pick<Poke<any>, 'app' | 'mark'> {
  action: 'poke';

  /**
   * Used for sending updates down appropriate subscription channel
   */
  returnSubscription:
    | WithMatcher<SubscriptionRequestInterface>
    | ((req: Message & Poke<any>) => WithMatcher<SubscriptionRequestInterface>);
  /**
   * The data responder is the actual data update generated by the poke
   * it requires a returnSubscription to send the update down the
   * appropriate channel
   */
  dataResponder: Responder<Poke<any>>;
  /**
   * Used for mocking the initial server response otherwise will respond
   * with default OK
   */
  initialResponder?: Responder<Poke<any>>;
  /**
   * Used for altering the immediate ID response otherwise will respond
   * with the ID generated
   */
  immediateResponder?: (req: Message & Poke<any>) => Promise<number>;
}

export function isPokeHandler(handler: Handler): handler is PokeHandler {
  return handler.action === 'poke';
}

export interface SubscriptionHandler
  extends WithMatcher<Pick<SubscriptionRequestInterface, 'app' | 'path'>> {
  action: 'subscribe';
  /**
   * Used for mocking the initial server response otherwise will respond
   * with default OK
   */
  initialResponder?: Responder<SubscriptionRequestInterface>;
  /**
   * Used for altering the immediate ID response otherwise will respond
   * with the ID generated
   */
  immediateResponder?: (
    req: Message & SubscriptionRequestInterface
  ) => Promise<number>;
}

export function isSubscriptionHandler(
  handler: Handler
): handler is SubscriptionHandler {
  return handler.action === 'subscribe';
}

export interface ThreadHandler extends Omit<Thread<any>, 'body'> {
  action: 'thread';
  /**
   * A function which generates a thread response
   */
  func: <Action>(req: Thread<Action>) => any;
}

export function isThreadHandler(handler: Handler): handler is ThreadHandler {
  return handler.action === 'thread';
}

export type Handler =
  | ScryHandler
  | PokeHandler
  | SubscriptionHandler
  | ThreadHandler;

export class ResumableError extends Error {}

export class FatalError extends Error {}
